<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angel Lugo | L07</title>
    <link rel="stylesheet" href="../css/small.css">
    <script src="../js/portfolio.js" defer></script>
</head>
<body>

    <header>
        <h1>WDD 330 - Web Delevopment II</h1>
        <h2>Angel Lugo Tehuitzil - Lesson 7 Notes</h2>
        <h2><a href="../index.html"><-- Home</a></h2>
    </header>
    
    <main>
        <h3>Chapter 11: Further Functions (JS Novice to Ninja)</h3>
        <p>This chapter starts by explaining that functions in JS have properties and methods, as they are first-class objects (I need to research what that means). One of the methods you can use in functions is call() and apply(). Which, in a few words, set the context of the function to an object set as the first parameter of the method. So, any “this” inside the function will point to the object that you passed as the first argument of the method call() or apply(). The only difference between those methods is that all arguments after the first one are passed as an array in the apply() method. This first time of the chapter also explains that you can set custom properties to your functions, as you would do with other objects. It also explains that you can use memoization which is storing the result of a certain operation in a function in the cache. So, when you use the same arguments in your function, instead of making the same operation again, you just get the result out of the cache.</p>
        <p>Then, it explains what are Immediately-Invoked Function Expressions (IIFE). These functions as its name suggests, are functions that are invoked immediately after they have been declared. They are isolated from the rest of the code, so all variables inside of it are kept under its scope, which keeps the rest of the code clean. One example they give for their usage is initialization code, which will only need to be run once. If you are working with code from others and you want to use strict mode, then you can keep all your code inside an IIFE and use strict there. There’s another option which is running your code inside curly braces, to keep it in a block, instead of using an IIFE.</p>
        <p>I learned also that you can write functions that redefine themselves after their first call. This is useful if you want them to do one specific thing the first time they are called and then continue with their new functionality after that. This is also useful when you are trying to check for browser compatibility. You could check for compatibility once and then redefine the function so that it doesn’t have to check for compatibility again, and instead, keep running with the code that works for the browser.</p>
        <p>Recursive functions are explained, which are functions that call themselves until a certain condition is met, kind of like a loop.</p>
        <p>The part that I was most interested in was the part about callbacks and how they are used in asynchronous programming. So, the book starts by just remembering that callbacks are functions that are passed to other functions as arguments, and then used inside these last functions. They are used asynchronously with events. For example, a callback could be a function that won’t do its stuff until someone triggers an event such as a click with the mouse. This would work asynchronously because the program won’t wait until someone clicks to trigger that function. It will pass the callback function to a queue, then process the rest of the code, and then once it’s done, it will check if someone clicked, and if that’s the case, it runs the callback function. They talk also about something called callback-hell, which is when you have too many nested callbacks. Because asynchronous programming can be used when your callbacks are waiting for a response from the server, sometimes errors happen. To solve this, there is a promise-based approach. A promise, as the book explains, “represents the future result of an asynchronous operation.” You don’t get an immediate result to work with, but instead, a promise, that when is settled it can return a result of resolved or rejected (error, or success). You can use the “then” and “catch” methods to handle the response once is settled; the first to handle a successful response, and the second to handle errors. This method allows us to create a chain of handlers so you can avoid callback hell. You can create promises, using a constructor function.</p>
        <p>The last thing I learned from this is that you can create asynchronous functions. You create them by adding the “async” keyword before writing your function. You can store the value of an asynchronous function in a variable using the “await” keyword before the function. This will store the value returned by your function once it is resolved.</p>
        <p>Then the book teaches about creating generalized functions that can perform additional operations if you pass them a callback function. It explains that functions can return more functions, and this can lead to creating a closure. A closure is when a function defined and returned inside another function keeps alive variables of the function that created this function. So, you have access to those variables.</p>
        <p>This lesson also explains generator functions. You create them by using an asterisk after the function declaration (function*). These functions keep the state of a value inside the function. For example, you can create a variable that holds a value and it increments by one inside your function; you return the value using the “yield” keyword instead of “return.” When you call a generator function, it doesn’t run the code inside your function but creates a generator object. You can store this object in a variable and pass it any initial values for example 1. Then use the next() method with that object in the variable. What the object will do is increment by one (as an example), and return the value. The trick here is that inside your object it keeps the new value, so every time you use the next() method, the object increments by one the value. It keeps the state of the value. This is just one example of a generator.</p>
        <p>I will end my notes with the most important thing I learned about the section “functional programming.” A key to using Functional Programming is what they call pure functions. A pure function follows three main rules: 1.- The returned value depends only on the values passed as arguments. It doesn’t get data from anywhere else. 2.- It doesn’t change any data outside the function. It only transforms the data passed as arguments. 3.- If it receives the same arguments, it should always return the same result.</p>
        <p>Besides these rules for pure functions, the key to functional programming is creating more generalized functions that perform simple tasks, and then together they achieve more complex tasks. </p>
        <p>This part explains two more types of functions. Higher-order functions, which are functions that accept other functions as arguments, or also return another function (some of the previous functions I mentioned would be higher-order). Then it explains currying functions. Currying, as the book explains, “is a process that involves the partial application of functions.” For example, you could create a function that accepts two arguments, but if only one is passed, you can return a function to which later you will pass the remaining argument. One argument at a time.</p>

        <h3>Chapter 8 (HTML5 & CSS33 for the Real World): Transforms and Transitions</h3>
        <p>The chapter starts by explaining what CSS Transforms are. In CSS you can use the “transform” property to change the position of an element on your page. There are four functions explained that you can use in the transform property: translate, scale, rotate and skew. When you use these functions of transform, they won’t affect the flow of the page. For example, changing the font-size could push elements around the text, but using transform all elements would stay in their place. Changes are relative to the center of the element, but you can change this with the transform-origin property, which changes the reference points for transforms. Here’s a little example of how you would use the transform property with three functions: “transform: rotate(10deg) translate(40px) scale(1.5);” The order in which you put your functions matters. A change following a previous one will take as its point of reference the position of the element after the previous transform function. In the last example, the element would rotate 10 degrees first, and then over its current rotated X-axis, it would move 40px.</p>
        <p>Then the chapter moves to “transitions.” When you make any change in your elements with transform, you can trigger those changes with a “hover” or by changing class names of your elements using JS. But you would see your elements transforming from their original appearance to the new one instantaneously. Transitions help you move from one appearance state to the other smoothly and gradually. The properties covered in the chapter are transition-property, transition-duration, transition-timing-function, and transition-delay. They reference the property to which you want to apply the transition, set the duration of the transition, set the speed variances throughout the transition, and the time for the transition to trigger once a change occurs respectively. They make the transition from their original position or state to the new one, and then backward. To achieve it you have to declare the original state of the element, then the final state of the element, and use the transition property inside the original state block of your element. Transitions only happen for a single change or movement. If you want several changes along the way to make more complex animations, you can use animations. Animations are based on frames, having as many frames as you want from beginning to end identified with percentages. In each frame, you can state what change or transformation you want to make on your elements.</p>

        <p>Because all of these concepts are about style, the book wasn’t enough for me to understand how these properties work, so I watched two very useful videos on YouTube:</p>
        <p><a target="_blank" href="https://www.youtube.com/watch?v=rzD-cPhq02E&t=591s">Learn CSS Transform In 15 Minutes</a></p>
        <p><a target="_blank" href="https://www.youtube.com/watch?v=YszONjKpgg4&t=609s">Learn CSS Animation In 15 Minutes</a></p>
    </main>

    <footer>
        <h2><a href="../index.html"><-- Home</a></h2>
        <p>&copy <span id="current-year"></span> | Angel Lugo Tehuitzil | <a target="_blank" href="https://www.byui.edu/online">BYU-I Online Learning</a></p>
        <p>Last update <span id="last-update"></span></p>
    </footer>
    
</body>
</html>